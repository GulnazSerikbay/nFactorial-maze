# -*- coding: utf-8 -*-
"""
ImageBounds.py

Name: Huda Baig
Andrew ID: hudab
"""

import ImageWriter

#checks whether difference in the values of two given rgb colour lists 
#are within the given threshold
def isCloseColor(rgb, expected, thr):

    #rgb lists always made up of 3 values
    for i in range(3):
        
        #take absolute value as don't know which list has larger value
        if abs(rgb[i] - expected[i]) > thr:
            return False
    
    #all values must be within threshold if function still running
    return True

#removes all 0 integers from a list destructively
def removeZeros(L):
    i = 0
    
    #use while loop as list size will change
    while i < len(L):
        if L[i] == 0:
            L.pop(i)
            
        #if item is not removed, need to manually shift to next item
        #as list does not shift down when no item deleted
        else:
            i += 1

#finds the amount of white gap in the pixel range of the given row in 
#given image
def oneHorizontalMargin(pic, start, end, step, h):
    margin = 0
    
    for w in range(start, end, step):
        
        #h is given row, and x coor obtained from given range
        colour = ImageWriter.getColor(pic, w, h)
        
        #full gap found when pixel is no longer white, and can stop check
        if isCloseColor(colour, [101, 154, 173], 50) == True:
            margin = w
            break
    
    return margin

#returns the pixel size of the right and left margin 
def findHorizontalMargin(pic):
    
    #store right and left margins of each row
    right = []
    left = []
    
    width = ImageWriter.getWidth(pic)
    height = ImageWriter.getHeight(pic)
    
    for h in range(height):
        
        #go from left for left margin and start from right for right margin
        leftMargin = oneHorizontalMargin(pic, 0, width, 1, h)
        
        rightMargin = oneHorizontalMargin(pic, width - 1, 0, -1, h)
        
        #right margin value counted from width, down so need to subtract
        #from width for absolute distance
        right.append(width - rightMargin)
        
        left.append(leftMargin)
    
    #the smallest margin is the one outlining the picture
    return (min(left), min(right))

#finds the amount of white gap in the pixel range of the given column in 
#given image
def oneVerticalMargin(pic, start, end, step, w):
    margin = 0
    
    for h in range(start, end, step):
        
        #w is given column and y coordinate in column generated by loop 
        #of given range
        colour = ImageWriter.getColor(pic, w, h)
        
        #full gap found when pixel is no longer white, and can stop check
        if isCloseColor(colour, [101, 154, 173], 50) == True:
            margin = h
            break
    
    return margin

#returns the pixel size of the top and bottom margin
def findVerticalMargin(pic):
    
    #store top and bottom margins of each row
    top = []
    bottom = []
    
    width = ImageWriter.getWidth(pic)
    height = ImageWriter.getHeight(pic)
    
    for w in range(width):
        
        #start checking from top for top margin
        topMargin = oneVerticalMargin(pic, 0, height, 1, w)
        
        #go in reverse for bottom margin to start checking from bottom
        bottomMargin = oneVerticalMargin(pic, height - 1, 0, -1, w)
        
        top.append(topMargin)
        
        #bottom margin values start from height so need to subtract 
        #from height for absolute distance
        bottom.append(height - bottomMargin)
    
    #the smallest margin is the one outlining the picture
    return (min(top), min(bottom))

#returns the x and y bounds of the image content without its margins
def mazeBounds(pic):
    
    #getting width, height and margins of image
    width = ImageWriter.getWidth(pic)
    wMargins = findHorizontalMargin(pic)
    
    height = ImageWriter.getHeight(pic)
    hMargins = findVerticalMargin(pic)
    
    #removing margins from original x and y bounds of image
    x0 = wMargins[0]
    x1 = width - wMargins[1]
    
    y0 = hMargins[0]
    y1 = height - hMargins[1]
    
    return x0, x1, y0, y1

#finds the bounds of a horizontal white pixel segment in a given row, and 
#column range and returns the center point of the segment
def findHorizontalWhiteBounds(pic, x0, x1, h):
    firstWhite = False
    bound1 = 0
    bound2 = 0
    
    
    for w in range(x0, x1):
        
        #x coordinate extracted from loop while y coor given
        colour = ImageWriter.getColor(pic, w, h)
        
        #finding location of first white pixel for segment
        if isCloseColor(colour, [255, 255, 255], 50) == True:
            if firstWhite == False:
                bound1 = w
                firstWhite = True
                
        #finding location of next coloured pixel which indicates end of 
        #white segment
        elif (isCloseColor(colour, [101, 154, 173], 50) == True and 
              firstWhite == True):
            bound2 = w
            break
            
    #finding average of bounds for center x point
    return ((bound1 + bound2) // 2, h)

#looks for horizontal white segment in a maze image's maze edge bounds
#as this is where the entrance to the maze could be found
def findHorizontalEntrance(pic):
    x0, x1, y0, y1 = mazeBounds(pic)
    
    entrance = findHorizontalWhiteBounds(pic, x0, x1, y0)
    
    #if no white segment found, x coor stays O, so must check opposite edge
    if entrance[0] == 0:
        entrance = findHorizontalWhiteBounds(pic, x0, x1, y1)
    
    #if still no white segment found, no white horizontal segment exists
    if entrance[0] == 0:
        return False
    
    return entrance

#finds the bounds of a vertical white pixel segment in given column,
#and row range and returns the center point of the segment
def findVerticalWhiteBounds(pic, y0, y1, w):
    firstWhite = False
    bound1 = 0
    bound2 = 0
    
    for h in range(y0, y1):
        
        #y coordinate extracted from loop while x coordinate given 
        colour = ImageWriter.getColor(pic, w, h)
        
        #finding location of first white pixel for segment
        if isCloseColor(colour, [255, 255, 255], 50) == True:
            if firstWhite == False:
                bound1 = h
                firstWhite = True
                
        #finding location of next coloured pixel which indicates end of 
        #white segment
        elif (isCloseColor(colour, [101, 154, 173], 50) == True and 
              firstWhite == True):
            bound2 = h
            break
    
    #finding average of bounds for center y point
    return (w, (bound1 + bound2) // 2)

#looks for vertical white segment in a maze image's maze edge bounds
#as this is where the entrance to the maze could be found
def findVerticalEntrance(pic):
    x0, x1, y0, y1 = mazeBounds(pic)
    
    entrance = findVerticalWhiteBounds(pic, y0, y1, x0)
    
    #if no white segment found, y coor stays O, so must check opposite edge
    if entrance[1] == 0: 
        entrance = findVerticalWhiteBounds(pic, y0, y1, x1)
    
    #if still no white segment found, no white vertical segment exists
    if entrance[1] == 0:
        return False
    
    return entrance

#looks for white segments on all four maze bounds to find maze exit
def findExit(pic, entrance):
    x0, x1, y0, y1 = mazeBounds(pic)
    
    #there are four bound ranges to be checked
    
    #first two tuples have col range and row, last two have row range
    #and col to be checked
    coors = [(x0, x1, y1), (x0, x1, y0), (y0, y1, x0), (y0, y1, x1)]
    
    #indicates which edge of maze stored bounds correspond to
    loc = ["bottom", "top", "left", "right"]
    
    for i in range(4):
        
        #check in x direction for first two bounds as have col ranges
        if i < 2:
            mazeExit = findHorizontalWhiteBounds(pic, coors[i][0], 
                                                 coors[i][1], coors[i][2])
            
        #check in y direction for last two bounds as have row ranges
        elif i >= 2:
            mazeExit = findVerticalWhiteBounds(pic, coors[i][0], 
                                               coors[i][1], coors[i][2])
        
        #if found segment not the same as entrance segment, must be exit
        
        #but any coordinate must not have stayed 0 as that means no 
        #segment was found
        if mazeExit != entrance and 0 not in mazeExit:
            break
    
    return mazeExit, loc[i]
